### 适配器模式	学习难度：★★☆☆☆，使用频率：★★★★☆ 

***

* **定义：** 将一个接口转换客户希望的另一个接口，使接口不兼容的那些类能够一起工作，又名包装器（Wrapper）。适配器模式可以为对象适配器模式，也可以是类适配器模式
* **对象适配器：**
  * 对象适配器模式包含如下角色
    * Target（目标抽象类）：定义客户所需接口，可以是接口、抽象类或者具体类
    * Adapter（适配器）：继承实现Target关联Adaptee，完成接口的转换
    * Adaptee（适配者）：定义存在的接口被适配器适配
  * 对象适配器的核心是适配器继承或者实现目标类委派适配者（关联关系）完成任务
  * 一个适配器能够适配多个适配者
* **类适配器：**
  * 包含角色与对象适配器一致
  * 适配器继承适配者类并实现目标抽象类接口
* **双向适配器：**
  * 包含角色与对象适配器一致
  * 对象适配器与类适配器的融合，像对象适配器一样关联适配者类，像类适配器一样实现目标接口
  * 适配器实现抽象目标类接口（该接口有功能实现类）和适配者接口（该接口有功能实现类）且都含有双方的引用，这样适配器就含有双方的所有方法且能够调用具体实现
* **缺省适配器（单接口适配器模式）：**
  * 抽象类实现接口并为所有方法提供默认实现（空实现）,子类继承抽象类并只重写部分方法
  * 包含如下角色
    * ServiceInterface（适配者接口）：定义大量抽象方法的接口
    * AbstractServiceClass（缺省适配器类）：缺省适配器的核心，实现适配者接口所有抽象方法并提供空实现
    * ConcreteServiceClass（具体业务类）：在存在缺省适配器类之前，它需要实现适配者接口并为所有抽象方法提供空实现，有了缺省适配器类之后，继承缺省适配器类，选择性覆盖需要使用的方法
* **优点：**使目标类和适配者类进行接口，提高了适配者类的复用性，可通过修改配置文件灵活配置适配者类
* **缺点：**类适配器不支持多重继承，适配者不能为最终类
* **适用场景：**适配者类代码丢失或者不能修改