### 装饰模式	学习难度：★★★☆☆，使用频率：★★★☆☆ 

------

- **前言**

  在现实的实际开发过程中，我们经常需要对原有类的功能进行扩展，在以往的做法中，我们是通过类的继承来增强类的功能，但是这样会出现两个问题第一是类的数量比较多，每一个对现有类的扩展，都要新建子类，另一个问题是类的功能扩展的顺序是固定的，这样就会导致功能扩展的不灵活

- **定义**

  装饰模式（Decorator Pattern）：动态的给一个对象增加一些职能，相对与生成子类更加灵活，

- **UML**

  ![装饰模式结构图](.\装饰模式结构图.png)

- **角色与过程**

  - 装饰模式共分为四种角色：
    - Component（抽象构件）：具体构件与抽象装饰类的共同父类，声明具体构件中实现的业务方法，它的出现能够让客户端一致的透明的对待装饰前和装饰后的类
    - ConcreteComponent（具体构件）：抽象构件的子类，实现具体的业务方法
    - Decorator（抽象装饰类）：抽象构件的子类，内部维持一个抽象构件的引用，通过该引用调用具体构件的业务方法
    - ConcreteDecorator（具体装饰类）：抽象装饰类的实现类，声明并实现各种装饰方法实现对具体构件的装饰
  - 具体构件和装饰具体构件的抽象装饰类通过注入的方式被抽象装饰类继续装饰
  - 因为具体构件和抽象装饰类都继承抽象构件，所以被装饰时可以被同样的对待
  
- **透明装饰模式与半透明装饰模式**

  透明装饰模式与半透明装饰模式的区别是，具体装饰类中的装饰方法能否被调用，具体装饰类与具体构件类能不能被一致透明对待

- **注意事项**

  - 尽量保持装饰类与被装饰类的接口相同，确保在客户端调用时能够被一致对待
  - 被装饰类尽量是一个“轻”类，较少的职能，通过装饰类对其进行扩展
  - 如果具体构件类只有一个，那么抽象装饰类可以直接是具体构件类的子类
  
- **优点**
  
  扩展一个类的功能，比继承更加灵活，且增加类的数量较少；具体装饰类和具体装饰类独立变化，符个开闭原则；类的装饰可以随意搭配顺序功能更为强大
  
- **缺点**
  
  小对象较多，耗费系统资源，排查问题困难
  
- **使用场景**
  
  在不影响其他对象的前提下，以透明、动态的方式添加类的职责；不能采用继承的场景下使用包含：其一系统中存在大量独立的扩展，职责的扩展会增加大量的类；其二被扩展的类是final修饰的类
  