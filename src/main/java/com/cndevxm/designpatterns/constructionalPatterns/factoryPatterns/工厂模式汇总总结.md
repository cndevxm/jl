## 工厂模式汇总总结

### 使用工厂模式的好处

* 一个类的职责可以分为三部分，分别为自身职责，创建职责，使用职责。但是在所有的工厂模式中我们都强调一点，两个类A和B之间的关系仅仅是A创建B或者是A使用B，而不能两者关系都有。这样更符合“单一职能原则”，使功能的复用性和系统的维护提高。
* 使用工厂模式可以防止用来实例化对象的数据和代码在多个类中到处都是，增加系统的冗余。
* 我们可以提供一系列名字不同的工厂方法，每个工厂方法对应一个构造函数，客户端可以以一种更加可读、易懂的方式创建对象。

***

### 简单工厂模式	学习难度：★★☆☆☆，使用频率：★★★☆☆ 

**定义：**定义一个工厂类，它可以根据不同的参数而返回不同类的实例，且这些实例具有共同的父类。因为在简单工厂模式中用于创建实例的方法为静态方法，所以简单工厂模式有被称为静态工厂模式，它属于类创建型模式。

**流程：**

* 简单工厂模式中的类 总共分为三种角色，工厂类、产品类、具体产品类。
  * Product（抽象产品角色）：所有具体产品的父类
  * Factory（工厂角色）：实现产品创建逻辑的类
  * ConcreteProduct（具体产品角色） ： 继承自抽象产品类的具体实现类
* 工厂类中包含静态工厂方法，出参为产品类，客户端通过传入不同入参去调用静态工厂方法去获取不同的具体产品类
* 工厂类中的静态工厂方法通过if else 判断去实例化不同的具体产品类

**改进：**将客户端调用工厂类的入参改为通过xml方式获取，这样不用修改代码即可实现更换具体产品类符合开闭原则。

**简化：**将工厂类与产品类合并，将工厂类中的静态工厂方法迁移至产品类中。

**优点：**

* 客户端可以免去直接创建产品对象的职责，而只是消费产品，简单工厂模式实现了创建与使用的职责分离
* 客户端无需知道创建产品类的类名，只需要知道具体产品类对应的参数，一定程度上减少了记忆量
* 通过引入配置文件的方式，可以在不修改客户端代码的情况下完成具体实现类的替换和增加，在一定程度上提高了系统的灵活性

**缺点：**

* 工厂模式集中了所有产品类的创建逻辑，如果出现问题，整个系统都要收到影响
* 增加系统中类的个数（工厂类），增加系统的复杂程度与理解难度
* 在产品类过多时造成工厂逻辑过于复杂，不利于系统的扩展与维护
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构

**适用场景：**

* 工厂类负责创建的对象比较少，不会造成工厂方法中的逻辑太过于复杂
* 客户端只知道闯入工厂类的参数，对于如何创建对象并不关心

***

### 工厂方法模式	学习难度：★★☆☆☆，使用频率：★★★★★

**定义：**定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到工厂类的子类。工厂方法模式简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。工厂方法模式是一种类创建型模式。 

**流程：**

* 工厂模式中的类 总共分为三种角色，抽象工厂、具体工厂、抽象产品、具体产品

  Factory（抽象工厂）：提供具体工厂所需要实现的接口集合，供客户端调用

  ConcreteFactory（具体工厂）：每一个具体的工厂生产一种具体的产品

  Product（抽象产品）：所有具体产品的父类

  ConcreteProduct（具体产品）：实现抽象产品类的具体的类，与具体工厂一一对应

  * 实例化具体工厂并将指针赋予抽象工厂
  * 调用抽象工厂的工厂方法完成环境配置与初始化操作以及具体产品的实例化
  * 将实例化的具体产品类赋予抽象产品类
  * 抽象产品类调用业务方法完成业务操作

**反射与配置文件 ：**通过xml读取与反射技术完成具体工厂实例化的实时更新（客户端读取配置文件而确定需要实例化哪个具体工厂，一般是在代码中指定具体的工厂类）

**工厂方法重载 ：**抽象工厂提供多个工厂方法以完成在不同业务场景下的灵活性

**工厂方法隐藏：**

* 实例化具体工厂并将指针赋予抽象工厂
* 封装工厂方法与产品类业务方法到抽象工厂中
  * 定义抽象工厂类型为抽象类
  * 抽象工厂定义一个具体方法封装工厂方法与产品的业务方法
* 调用抽象工厂的自定义方法即可完成产品的创建与业务方法的调用

**优点：**符合开闭原则，隐藏具体产品类细节，客户端无需知道具体产品类名，即可完成具体产品的创建

**缺点：**具体工厂类与具体产品类成对出现，增加系统复杂度。

**适用场景：**客户端不知道具体产品类

***

### 抽象工厂模式	学习难度：★★★★☆，使用频率：★★★★★

**产品等级结构和产品组：**以电器厂为例子，一类产品为一个产品等级结构，像电视为一个产品等级结构下面包含海信电视、创维电视、小米电视等，多个不同产品类的产品构成了一个产品组。

**定义：**提供一个创建一系列相关或者相互依赖的类的工厂接口，他包含多个产品类的工厂方法。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。 

**流程：**

* 抽象工厂模式总共包含四种角色，抽象工厂、具体工厂、抽象产品、具体产品

  AbstractFactory（抽象工厂）：包含多个创建同一产品族中产品的抽象工厂方法的抽象类，一个抽象工厂定义了一个输出产品族

  ConcreteFactory（具体工厂）：抽象工厂的实现。

  AbstractProduct（抽象产品）：所有具体产品的父类，这里指单一产品而不是一个产品族

  ConcreteProduct（具体产品）：具体的产品

* 实际上抽象工厂模式与工厂方法模式抽象产品与具体产品的角色是一致的，不同的只是工厂定义的不同，工厂方法中的工厂只生产单一产品，而抽象工厂的工厂生产的是一个产品族的产品

**开闭原则的倾斜性：**对于开闭原则，增加产品等级结构是不遵守开闭原则，增加产品等级结构势必会在抽象工厂中添加新的工厂方法以生产新的产品，而增加新的产品族实际上是新增新的具体工厂，这和工厂方法模式是保持一致的遵守开闭原则

**优点：**一定程度上减少工厂类的创建，符合开闭原则。

**缺点：**添加新的产品等级结构时不符合开闭原则

**适用场景：**用户不关心对像的创建，产品等级结构设计稳定，后期不会改动



